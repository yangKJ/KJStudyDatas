## c语言文档

### 总结下c语言常用的东西
* [函数指针声明与赋值](#函数指针声明与赋值)
* [关键字](#关键字)
* [变量占用内存](#变量占用内存)
* [运算符](#运算符)
* [结构体嵌套](#结构体嵌套)
* [原码补码反码](#原码补码反码)

#### <a id="函数指针声明与赋值"></a>函数指针声明与赋值
```
int func (int count) {
    return count + 1;
}
int (*funcptr)(int) = &func;
```

#### <a id="关键字"></a>关键字
```
1.关键字 都是小写
2.有特殊的颜色
3.C语言一共有32个关键字    

1.基本数据类型(5个)
void    : 声明函数 无返回值 或 无参数, 声明无类型
char    : 字符型类型数据, 属性整形数据的一种
int     : 整型数据, 通常为编译器指定的机器字
float   : 单精度浮点型数据, 属性浮点数据的一种
double  : 双精度浮点型数据, 数据浮点数据
 
2.类型修饰  关键字(4个)
short   : 修饰int, 短整型数据,可省略被修饰的
long    : 修饰int, 长整型数据,可省略被修饰的
signed  : 修饰整型数据, 有符号数据类型
unsigned: 修饰整型数据, 无符号数据类型
 
3.复杂类型  关键字(5个)
struct  : 结构体 声明
union   : 共用体 声明
enum    : 枚举  声明
typedef : 声明类型别名
sizepf  : 得到特定类型,计算类型变量占用的大小(内存字节数)
 
4.存储级别关键字(6个)
auto    : 指定为自动变量,由编译器自动分配
static  : 指定为静态变量,分配在静态变量区
register: 指定为寄存器变量,建议编译器将通过寄存器而不是堆栈传递数据
extern  : 指定对应变量为外部变量,即标示变函数时在其它模块中寻找其定义
const   : 与volatile合称"cv特性",指定变量不改变
volatile: 与const合称"cv特性",指定变量的内存中取得该变量的值

1.跳转结构(4个)
return  : 用户函数体中, 返回特定值(或者是)
continue: 结束当前循环, 开始下一轮循环
break   : 跳出当前循环或 switch结构
goto    : 无条件跳转语句
 
2.分支结构(5个)
if      : 条件语句,后面不需要放分号
else    : 条件语句 否定分支(与if连用)
switch  : 开关语句(多重分支语句)
case    : 开关语句中的分支标记
default : 开关语句中的"其它"分支,可选
 
3.循环结构(3个)
for     : for循环结构,for(1;2;3)4;的执行顺序为程序中,表达式1只计算一次，表达式2和表达式 执行页可以能一次都不执行
do      : do循环结构, do 1 while(2);的执行顺序
while   : while循环结构, while(1)2;的执行顺序,表达式为真,则继续循环, 为假则跳出循环
```
#### <a id="变量占用内存"></a>变量占用内存
```
1. 字节和地址
内存就是字节，内存以“字节为单位”
2. 变量的存储 占据的存储空间
一个变量所占用的存储空间，不仅跟变量类型有关，而且还跟编译器环境有关。同一种类型的变量，在不同编译器环境下所占用的存储空间又是不一样的
* 所占用字节数跟类型有关，也跟编译器环境有关
* 内存由大到下寻址
* 变量存储单元的第一个字节的地址就是该变量的地址
* 任何变量在内存中都是以二进制的形式存储。一个负数的二进制形式，其实就是对它的正数的二进制形式进行取反后再＋1（取反的意思就是0变1，1变0）

类型       16位  32位  64位(只关注64 因为是Mac都是64位的)
char       1     1     1
int        2     4     4
float      4     4     4
double     8     8     8
short      2     2     2
long       2     2     2
long long  2     2     2
void*      2     4     8
```
#### <a id="运算符"></a>运算符
```
<<  二进制左移运算符 60 << 2 将得到 240，即为 1111 0000
>>  二进制右移运算符 60 >> 2 将得到 15，即为 0000 1111
sizeof()  返回变量的大小	sizeof(a) 将返回 4，其中 a 是整数。
&  返回变量的地址	&a将给出变量的实际地址。
*  指向一个变量  *a将指向一个变量。
```
#### <a id="结构体嵌套"></a>结构体嵌套
```
// 定义一个时间结构体类型
// 出生时间
struct Time {
    int HH;
    int mm;
    int ss;
};
struct Date {
    int year;
    int month;
    int day;
    struct Time time;
};
struct Date date = {1998,3,4,{12,13,14}};
NSLog(@"year = %i,HH = %i",date.year,date.time.HH);
```
#### <a id="原码补码反码"></a>原码补码反码
```
// 其实,数据存储在内存中都是存储的二进制
// 二进制又可以分为 源码／反码／补码
// 其实最终存储在内存中的 是“补码”
#pragma mark 正数存储的 原码、补码、反码
// 9 --> 存储在内存中 --> 二进制
// 9 是整型 == int == 4个字节 == 1个字节8位 == 整型有32位
0000 0000 0000 0000 0000 0000 0000 1001 (原码)
什么是反码 ,正数的反码就是正数的原码
什么是补码 ,正数的补码就是正数的原码
总结一句话 : 正数的原码补码反码都是一样的 , 三码合一
    
#pragma mark 负数存储的 原码、补码、反码
 // -9 --> 存储在内存中 --> 二进制
 其实二进制的第一位是二进制的符号位,如果该位是0代表这个数是一个正数
 1000 0000 0000 0000 0000 0000 0000 1001 (原码)
 反码 : 符号位不变, 其他位取反(0变1 1变0)
 1111 1111 1111 1111 1111 1111 1111 0110 (反码)
 补码 : 反码 + 1 就是补码
 1111 1111 1111 1111 1111 1111 1111 0110 (反码)
+0000 0000 0000 0000 0000 0000 0000 0001
 1111 1111 1111 1111 1111 1111 1111 0111 (补码)

#pragma mark 练习
-15 的原码/ 反码 / 补码
1000 0000 0000 0000 0000 0000 0000 1111 (原码)
1111 1111 1111 1111 1111 1111 1111 0000 (反码)
1111 1111 1111 1111 1111 1111 1111 0001 (补码)
 
为什么要有原码/补码/反码呢？主要是为了方便计算机计算
1.由于最高位是符号位,如果是0就代表是整数,如果是1就代表是负数
2.那么如果直接存储原码,计算机在计算的时候还需要先判断最高位才能计算,效率比较低
3.为了方便计算机计算,所以有了反码和补码,有了反码和补码之后,以后计算机就不需要判断最高位了,直接计算就可以
 
 1 + 1
 0001
+0001
-------
 0010 == 2
 
#pragma mark 在原码的思想上做计算 结果是错的
 1 - 1 == 1 + (-1) == 计算机只会做加法
 0000 0001  // 原码
+1000 0001  // 原码
 ----------
 1000 0010 == -2
     
#pragma mark 在反码的思想上做计算
 1 - 1 = 1 + (-1)
 0000 0001  // 正1的原码(反码)
 1111 1110  // 负1的反码
 ----------
 1111 1111  == 反码
 将计算出来的反码转换为原码,再将原码转换为十进制
 1000 0000  == 原码 == -0
 
#pragma mark 在补码的思想上做计算
 1 - 1 = 1 + (-1)
 0000 0001  // 正1的补码
+1111 1111  // 负1的补码(是在负1的反码基础上 加上1 变成了补码)
---------
1 0000 0000  == - 0
```